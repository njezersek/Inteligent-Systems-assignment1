---
title: "Assignment1"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Libraries
```{r}
library(GA)
```

## Population
```{r}
numbers_and_operators <- c("10", "25", "100", "5", "3", "+", "-", "/", "*")
operator_min <- 6
operator_max <- 9
n_numbers <- 5
expression_length <- n_numbers * 2 - 1
target_value <- 2512
```

## Generate population
This function generates a random agent represented by indices of 
`numbers_and_operators`.

Agent is generated by choosing 4 random operators (`+`. `-`, `/`, `*`) with
possible repetition and by random permutation of numbers (`10`.`25`,`100`,`5`,
`3`).
```{r}
generate_agent <- function(){
  operator_indices <- round(runif(n_numbers - 1, operator_min, operator_max))
  number_indices <- sample(1:n_numbers, n_numbers)
  indices <- vector(length=expression_length)
  indices[seq(1, expression_length, 2)] <- number_indices
  indices[seq(2, expression_length, 2)] <- operator_indices
  
  return(indices)
}
```


Here is a sample agent:
```{r}
agent <- generate_agent()
agent
```

This function generates a random population by repetitive calling of 
`generate_agent` .
```{r}
generate_population <- function(object) {
  indices <- matrix(NA, nrow = object@popSize, ncol = expression_length)
  for (i in 1:object@popSize) {
    indices[i, ] <- generate_agent()
  }

  return(indices)
}
```

## Fitness function
Fitness function evaluates the expression and compares the result with 
`target_value`.
```{r}
my_fitness <- function(agent) {
  a <- numbers_and_operators[agent]
  val <- eval(parse(text = paste(a, collapse = "")))
  return(-abs(val - target_value))
}
```
## Print agent function
```{r}
print_agent <- function(agent){
  expression = paste(numbers_and_operators[agent], collapse = "")
  value = eval(parse(text = expression))
  fitness = my_fitness(agent)
  print(paste(
    c(
      "[", paste(agent, collapse = ", "), "]", 
      "; ", expression, " = ", value, "; fitness = ", fitness
    ), collapse = ""
  ))
}

print_agent(agent)
```

## Mutation function
```{r}
my_mutation <- function(object, parent) {
  mutate <- parent <- as.vector(object@population[parent, ])
  n <- n_numbers * 2 - 1
  rand <- round(runif(1, 0, 1)) # rand: 0 = number, 1 = operator
  swap <- seq(1 + rand, n, 2)   # 0 -> (1 3 5 7 9)    1 -> (2 4 6 8)

  # swap 2 numbers / operators
  indexes <- sample(swap, 2)
  mutate[indexes[1]] <- parent[indexes[2]]
  mutate[indexes[2]] <- parent[indexes[1]]

  return(mutate)
}
```

## Crossover function
```{r}
my_crossover <- function(object, parent) {
  pop <- object@population
  n <- n_numbers * 2 - 1
  p1 <- pop[parent[1], ]
  p2 <- pop[parent[2], ]
  children <- matrix(NA, nrow = 2, ncol = n)
  children[1, ] <- p1
  children[2, ] <- p2

  ssize <- round(runif(1, 1, n_numbers - 1))
  switch_indices <- sample(seq(2, n, 2), ssize)

  children[1, switch_indices] <- p2[switch_indices]
  children[2, switch_indices] <- p1[switch_indices]

  return(list(children = children, fitness = rep(NA, 2)))
}
```

```{r}
GA <- ga(type = "permutation", population = generate_population,
          fitness = my_fitness,
          mutation = my_mutation,
          crossover = my_crossover,
          maxFitness = 0,
          maxiter = 500,

          popSize = 256, lower = 1, upper = 9)
summary(GA)

for (i in 1:nrow(GA@solution)) {
  mat <- c(t(matrix(GA@solution[i, ])))
  print(paste(numbers_and_operators[mat], collapse = ""))
}
```

